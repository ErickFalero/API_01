# -*- coding: utf-8 -*-
"""Análisis vibración.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H-NEXQbd68nSfBsJuxQrBjYUlv_9XpEj
"""

import os
import pandas as pd
import dash
from dash import dcc, html, Input, Output
import plotly.express as px
from jupyter_dash import JupyterDash
from IPython.display import display

# Ruta correcta
ruta_archivos = r'C:\Users\efalerop\Desktop\IA - MONITOREO\08.- HEROKU\MOTOR'

# Verificar si la ruta existe
if os.path.exists(ruta_archivos):
    # Obtener lista de archivos CSV
    files = [os.path.join(ruta_archivos, f) for f in os.listdir(ruta_archivos) if f.endswith('.csv')]
    print("Archivos encontrados:", files)
else:
    raise FileNotFoundError("La ruta especificada no existe o no contiene archivos CSV.")

# Función para procesar cada archivo
def process_file(file_path):
    df = pd.read_csv(file_path, skiprows=60)
    df = df.iloc[:, [0, 1]]  # Conservar solo las primeras dos columnas
    filename = os.path.basename(file_path)  # Obtener solo el nombre del archivo
    df.columns = ['Hz', filename]  # Renombrar las columnas
    return df

# Procesar todos los archivos
processed_files = [process_file(file) for file in files]

# Unir todos los archivos en la columna 'Hz'
merged_df = processed_files[0]
for df in processed_files[1:]:
    merged_df = pd.merge(merged_df, df, on='Hz', how='outer', suffixes=('', '_dup'))
merged_df = merged_df.loc[:, ~merged_df.columns.str.endswith('_dup')]  # Eliminar columnas duplicadas

# Función para detectar anomalías
def detectar_anomalias(df):
    for col in df.columns[1:]:  # Ignorar la columna 'Hz'
        anomalía_col = col + '_anomalía'
        df[anomalía_col] = df.apply(lambda row:
                                    (row['Hz'] < 60 and row[col] > 6.5) or
                                    (60 <= row['Hz'] <= 120 and row[col] >= 2.8) or
                                    (row['Hz'] > 120 and row[col] > 1.5), axis=1)
    return df

# Detectar anomalías
merged_df_anomalies = detectar_anomalias(merged_df)

# Función para obtener la causa y la acción recomendada según las anomalías
def obtener_diagnostico(frecuencia, valor):
    if frecuencia < 60 and valor > 6.5:
        causa = "Distribución de masa desigual en el rotor."
        accion = "Balancear el rotor o cambiar componentes defectuosos."
    elif 60 <= frecuencia <= 120 and valor >= 2.8:
        causa = "Ejes desalineados, acoplamientos defectuosos."
        accion = "Realinear los ejes utilizando herramientas de alineación."
    elif frecuencia > 120 and valor > 1.5:
        causa = "Desgaste en los componentes del rodamiento o falta de lubricación."
        accion = "Revisar y reemplazar los rodamientos, mejorar la lubricación."
    else:
        causa = "Sin anomalía clara."
        accion = "No se requiere acción."
    return causa, accion

# Resumir si los datos tienen o no anomalías
def resumir_anomalias(df):
    resumen = pd.DataFrame(columns=['Archivo', 'Tiene Anomalías'])
    for col in df.columns[1:]:
        if '_anomalía' in col:
            archivo = col.replace('_anomalía', '')
            tiene_anomalia = df[col].any()
            nuevo_dato = pd.DataFrame({'Archivo': [archivo], 'Tiene Anomalías': ['Sí' if tiene_anomalia else 'No']})
            resumen = pd.concat([resumen, nuevo_dato], ignore_index=True)
    return resumen

# Aplicar el resumen de anomalías
resumen_anomalias = resumir_anomalias(merged_df_anomalies)

# Función para resaltar colores en el DataFrame (rojo si tiene anomalía, verde si no tiene)
def resaltar_anomalias(val):
    color = 'background-color: red' if val == 'Sí' else 'background-color: green'
    return color

# Mostrar el DataFrame resaltado
resumen_anomalias_styled = resumen_anomalias.style.applymap(resaltar_anomalias, subset=['Tiene Anomalías'])

# Mostrar DataFrame con colores
display(resumen_anomalias_styled)

# Crear la aplicación Dash con JupyterDash
app = JupyterDash(__name__)

# Layout de la aplicación
app.layout = html.Div([
    html.H1("Análisis de Anomalías en Gráficos"),
    dcc.Dropdown(
        id='dropdown-variable',
        options=[{'label': col, 'value': col} for col in merged_df.columns[1:-1] if '_anomalía' not in col],
        value=merged_df.columns[1],  # Valor por defecto
        clearable=False
    ),
    dcc.Graph(id='graph-output'),
    html.Div(id='diagnostico-output')
])

# Callback para actualizar el gráfico dinámicamente
@app.callback(
    [Output('graph-output', 'figure'), Output('diagnostico-output', 'children')],
    [Input('dropdown-variable', 'value')]
)
def update_graph(variable):
    frecuencia = merged_df['Hz']
    valores = merged_df[variable]

    # Graficar puntos normales en azul
    fig = px.line(x=frecuencia, y=valores, labels={'x': 'Frecuencia (Hz)', 'y': 'Valor'}, title=f"Análisis de {variable}")

    # Graficar anomalías en rojo
    anomalía_col = variable + '_anomalía'
    anomalos = merged_df[merged_df[anomalía_col] == True]
    fig.add_scatter(x=anomalos['Hz'], y=anomalos[variable], mode='markers', marker=dict(color='red'), name='Anomalías')

    # Mostrar diagnóstico para cada anomalía
    diagnostico = []
    for _, row in anomalos.iterrows():
        causa, accion = obtener_diagnostico(row['Hz'], row[variable])
        diagnostico.append(html.Div([
            html.P(f"Anomalía detectada en {variable}: Frecuencia {row['Hz']} Hz, Valor {row[variable]}"),
            html.P(f"Causa: {causa}"),
            html.P(f"Acción recomendada: {accion}")
        ]))

    return fig, diagnostico

# Ejecutar la aplicación en modo normal
if __name__ == '__main__':
    app.run_server(debug=True)